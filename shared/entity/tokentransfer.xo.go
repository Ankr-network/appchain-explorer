package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"github.com/lib/pq"
	"time"
)

// TokenTransfer represents a row from 'public.token_transfers'.
type TokenTransfer struct {
	TransactionHash          []byte          `json:"transaction_hash"`            // transaction_hash
	LogIndex                 int             `json:"log_index"`                   // log_index
	FromAddressHash          []byte          `json:"from_address_hash"`           // from_address_hash
	ToAddressHash            []byte          `json:"to_address_hash"`             // to_address_hash
	Amount                   sql.NullFloat64 `json:"amount"`                      // amount
	TokenID                  sql.NullFloat64 `json:"token_id"`                    // token_id
	TokenContractAddressHash []byte          `json:"token_contract_address_hash"` // token_contract_address_hash
	InsertedAt               time.Time       `json:"inserted_at"`                 // inserted_at
	UpdatedAt                time.Time       `json:"updated_at"`                  // updated_at
	BlockNumber              sql.NullInt64   `json:"block_number"`                // block_number
	BlockHash                []byte          `json:"block_hash"`                  // block_hash
	Amounts                  pq.Float64Array `json:"amounts"`                     // amounts
	TokenIDs                 pq.Float64Array `json:"token_ids"`                   // token_ids
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the TokenTransfer exists in the database.
func (tt *TokenTransfer) Exists() bool {
	return tt._exists
}

// Deleted returns true when the TokenTransfer has been marked for deletion from
// the database.
func (tt *TokenTransfer) Deleted() bool {
	return tt._deleted
}

// Insert inserts the TokenTransfer to the database.
func (tt *TokenTransfer) Insert(ctx context.Context, db DB) error {
	switch {
	case tt._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case tt._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.token_transfers (` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13` +
		`)`
	// run
	logf(sqlstr, tt.TransactionHash, tt.LogIndex, tt.FromAddressHash, tt.ToAddressHash, tt.Amount, tt.TokenID, tt.TokenContractAddressHash, tt.InsertedAt, tt.UpdatedAt, tt.BlockNumber, tt.BlockHash, tt.Amounts, tt.TokenIDs)
	if _, err := db.ExecContext(ctx, sqlstr, tt.TransactionHash, tt.LogIndex, tt.FromAddressHash, tt.ToAddressHash, tt.Amount, tt.TokenID, tt.TokenContractAddressHash, tt.InsertedAt, tt.UpdatedAt, tt.BlockNumber, tt.BlockHash, tt.Amounts, tt.TokenIDs); err != nil {
		return logerror(err)
	}
	// set exists
	tt._exists = true
	return nil
}

// Update updates a TokenTransfer in the database.
func (tt *TokenTransfer) Update(ctx context.Context, db DB) error {
	switch {
	case !tt._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case tt._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.token_transfers SET ` +
		`from_address_hash = $1, to_address_hash = $2, amount = $3, token_id = $4, token_contract_address_hash = $5, inserted_at = $6, updated_at = $7, block_number = $8, amounts = $9, token_ids = $10 ` +
		`WHERE transaction_hash = $11 AND log_index = $12 AND block_hash = $13`
	// run
	logf(sqlstr, tt.FromAddressHash, tt.ToAddressHash, tt.Amount, tt.TokenID, tt.TokenContractAddressHash, tt.InsertedAt, tt.UpdatedAt, tt.BlockNumber, tt.Amounts, tt.TokenIDs, tt.TransactionHash, tt.LogIndex, tt.BlockHash)
	if _, err := db.ExecContext(ctx, sqlstr, tt.FromAddressHash, tt.ToAddressHash, tt.Amount, tt.TokenID, tt.TokenContractAddressHash, tt.InsertedAt, tt.UpdatedAt, tt.BlockNumber, tt.Amounts, tt.TokenIDs, tt.TransactionHash, tt.LogIndex, tt.BlockHash); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the TokenTransfer to the database.
func (tt *TokenTransfer) Save(ctx context.Context, db DB) error {
	if tt.Exists() {
		return tt.Update(ctx, db)
	}
	return tt.Insert(ctx, db)
}

// Upsert performs an upsert for TokenTransfer.
func (tt *TokenTransfer) Upsert(ctx context.Context, db DB) error {
	switch {
	case tt._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.token_transfers (` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13` +
		`)` +
		` ON CONFLICT (transaction_hash, log_index, block_hash) DO ` +
		`UPDATE SET ` +
		`from_address_hash = EXCLUDED.from_address_hash, to_address_hash = EXCLUDED.to_address_hash, amount = EXCLUDED.amount, token_id = EXCLUDED.token_id, token_contract_address_hash = EXCLUDED.token_contract_address_hash, inserted_at = EXCLUDED.inserted_at, updated_at = EXCLUDED.updated_at, block_number = EXCLUDED.block_number, amounts = EXCLUDED.amounts, token_ids = EXCLUDED.token_ids `
	// run
	logf(sqlstr, tt.TransactionHash, tt.LogIndex, tt.FromAddressHash, tt.ToAddressHash, tt.Amount, tt.TokenID, tt.TokenContractAddressHash, tt.InsertedAt, tt.UpdatedAt, tt.BlockNumber, tt.BlockHash, tt.Amounts, tt.TokenIDs)
	if _, err := db.ExecContext(ctx, sqlstr, tt.TransactionHash, tt.LogIndex, tt.FromAddressHash, tt.ToAddressHash, tt.Amount, tt.TokenID, tt.TokenContractAddressHash, tt.InsertedAt, tt.UpdatedAt, tt.BlockNumber, tt.BlockHash, tt.Amounts, tt.TokenIDs); err != nil {
		return logerror(err)
	}
	// set exists
	tt._exists = true
	return nil
}

// Delete deletes the TokenTransfer from the database.
func (tt *TokenTransfer) Delete(ctx context.Context, db DB) error {
	switch {
	case !tt._exists: // doesn't exist
		return nil
	case tt._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM public.token_transfers ` +
		`WHERE transaction_hash = $1 AND log_index = $2 AND block_hash = $3`
	// run
	logf(sqlstr, tt.TransactionHash, tt.LogIndex, tt.BlockHash)
	if _, err := db.ExecContext(ctx, sqlstr, tt.TransactionHash, tt.LogIndex, tt.BlockHash); err != nil {
		return logerror(err)
	}
	// set deleted
	tt._deleted = true
	return nil
}

// TokenTransfersByBlockNumberLogIndex retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_block_number_DESC_log_index_DESC_index'.
func TokenTransfersByBlockNumberLogIndex(ctx context.Context, db DB, blockNumber sql.NullInt64, logIndex int) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE block_number = $1 AND log_index = $2`
	// run
	logf(sqlstr, blockNumber, logIndex)
	rows, err := db.QueryContext(ctx, sqlstr, blockNumber, logIndex)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TokenTransfersByBlockNumber retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_block_number_index'.
func TokenTransfersByBlockNumber(ctx context.Context, db DB, blockNumber sql.NullInt64) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE block_number = $1`
	// run
	logf(sqlstr, blockNumber)
	rows, err := db.QueryContext(ctx, sqlstr, blockNumber)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TokenTransfersByFromAddressHashTransactionHash retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_from_address_hash_transaction_hash_index'.
func TokenTransfersByFromAddressHashTransactionHash(ctx context.Context, db DB, fromAddressHash, transactionHash []byte) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE from_address_hash = $1 AND transaction_hash = $2`
	// run
	logf(sqlstr, fromAddressHash, transactionHash)
	rows, err := db.QueryContext(ctx, sqlstr, fromAddressHash, transactionHash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TokenTransferByTransactionHashBlockHashLogIndex retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_pkey'.
func TokenTransferByTransactionHashBlockHashLogIndex(ctx context.Context, db DB, transactionHash, blockHash []byte, logIndex int) (*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE transaction_hash = $1 AND block_hash = $2 AND log_index = $3`
	// run
	logf(sqlstr, transactionHash, blockHash, logIndex)
	tt := TokenTransfer{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, transactionHash, blockHash, logIndex).Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
		return nil, logerror(err)
	}
	return &tt, nil
}

// TokenTransfersByToAddressHashTransactionHash retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_to_address_hash_transaction_hash_index'.
func TokenTransfersByToAddressHashTransactionHash(ctx context.Context, db DB, toAddressHash, transactionHash []byte) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE to_address_hash = $1 AND transaction_hash = $2`
	// run
	logf(sqlstr, toAddressHash, transactionHash)
	rows, err := db.QueryContext(ctx, sqlstr, toAddressHash, transactionHash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TokenTransfersByTokenContractAddressHashBlockNumber retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_token_contract_address_hash_block_number_index'.
func TokenTransfersByTokenContractAddressHashBlockNumber(ctx context.Context, db DB, tokenContractAddressHash []byte, blockNumber sql.NullInt64) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE token_contract_address_hash = $1 AND block_number = $2`
	// run
	logf(sqlstr, tokenContractAddressHash, blockNumber)
	rows, err := db.QueryContext(ctx, sqlstr, tokenContractAddressHash, blockNumber)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TokenTransfersByTokenContractAddressHashTokenIDBlockNumber retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_token_contract_address_hash_token_id_DESC_block'.
func TokenTransfersByTokenContractAddressHashTokenIDBlockNumber(ctx context.Context, db DB, tokenContractAddressHash []byte, tokenID sql.NullFloat64, blockNumber sql.NullInt64) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE token_contract_address_hash = $1 AND token_id = $2 AND block_number = $3`
	// run
	logf(sqlstr, tokenContractAddressHash, tokenID, blockNumber)
	rows, err := db.QueryContext(ctx, sqlstr, tokenContractAddressHash, tokenID, blockNumber)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TokenTransfersByTokenContractAddressHashTransactionHash retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_token_contract_address_hash_transaction_hash_in'.
func TokenTransfersByTokenContractAddressHashTransactionHash(ctx context.Context, db DB, tokenContractAddressHash, transactionHash []byte) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE token_contract_address_hash = $1 AND transaction_hash = $2`
	// run
	logf(sqlstr, tokenContractAddressHash, transactionHash)
	rows, err := db.QueryContext(ctx, sqlstr, tokenContractAddressHash, transactionHash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TokenTransfersByTokenID retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_token_id_index'.
func TokenTransfersByTokenID(ctx context.Context, db DB, tokenID sql.NullFloat64) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE token_id = $1`
	// run
	logf(sqlstr, tokenID)
	rows, err := db.QueryContext(ctx, sqlstr, tokenID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TokenTransfersByTransactionHashLogIndex retrieves a row from 'public.token_transfers' as a TokenTransfer.
//
// Generated from index 'token_transfers_transaction_hash_log_index_index'.
func TokenTransfersByTransactionHashLogIndex(ctx context.Context, db DB, transactionHash []byte, logIndex int) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT ` +
		`transaction_hash, log_index, from_address_hash, to_address_hash, amount, token_id, token_contract_address_hash, inserted_at, updated_at, block_number, block_hash, amounts, token_ids ` +
		`FROM public.token_transfers ` +
		`WHERE transaction_hash = $1 AND log_index = $2`
	// run
	logf(sqlstr, transactionHash, logIndex)
	rows, err := db.QueryContext(ctx, sqlstr, transactionHash, logIndex)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*TokenTransfer
	for rows.Next() {
		tt := TokenTransfer{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// Block returns the Block associated with the TokenTransfer's (BlockHash).
//
// Generated from foreign key 'token_transfers_block_hash_fkey'.
func (tt *TokenTransfer) Block(ctx context.Context, db DB) (*Block, error) {
	return BlockByHash(ctx, db, tt.BlockHash)
}

// Address returns the Address associated with the TokenTransfer's (TokenContractAddressHash).
//
// Generated from foreign key 'token_transfers_token_contract_address_hash_fkey'.
func (tt *TokenTransfer) Address(ctx context.Context, db DB) (*Address, error) {
	return AddressByHash(ctx, db, tt.TokenContractAddressHash)
}

// Transaction returns the Transaction associated with the TokenTransfer's (TransactionHash).
//
// Generated from foreign key 'token_transfers_transaction_hash_fkey'.
func (tt *TokenTransfer) Transaction(ctx context.Context, db DB) (*Transaction, error) {
	return TransactionByHash(ctx, db, tt.TransactionHash)
}

// TokenTransfersByHash runs a custom query, returning results as TokenTransfer.
func TokenTransfersByHash(ctx context.Context, db DB, hash []byte) ([]*TokenTransfer, error) {
	// query
	const sqlstr = `SELECT * FROM "token_transfers" ` +
		`WHERE transaction_hash = $1`
	// run
	logf(sqlstr, hash)
	rows, err := db.QueryContext(ctx, sqlstr, hash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*TokenTransfer
	for rows.Next() {
		var tt TokenTransfer
		// scan
		if err := rows.Scan(&tt.TransactionHash, &tt.LogIndex, &tt.FromAddressHash, &tt.ToAddressHash, &tt.Amount, &tt.TokenID, &tt.TokenContractAddressHash, &tt.InsertedAt, &tt.UpdatedAt, &tt.BlockNumber, &tt.BlockHash, &tt.Amounts, &tt.TokenIDs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &tt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
