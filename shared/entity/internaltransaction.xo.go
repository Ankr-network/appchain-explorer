package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// InternalTransaction represents a row from 'public.internal_transactions'.
type InternalTransaction struct {
	CallType                   sql.NullString  `json:"call_type"`                     // call_type
	CreatedContractCode        []byte          `json:"created_contract_code"`         // created_contract_code
	Error                      sql.NullString  `json:"error"`                         // error
	Gas                        sql.NullFloat64 `json:"gas"`                           // gas
	GasUsed                    sql.NullFloat64 `json:"gas_used"`                      // gas_used
	Index                      int             `json:"index"`                         // index
	Init                       []byte          `json:"init"`                          // init
	Input                      []byte          `json:"input"`                         // input
	Output                     []byte          `json:"output"`                        // output
	TraceAddress               []int           `json:"trace_address"`                 // trace_address
	Type                       string          `json:"type"`                          // type
	Value                      float64         `json:"value"`                         // value
	InsertedAt                 time.Time       `json:"inserted_at"`                   // inserted_at
	UpdatedAt                  time.Time       `json:"updated_at"`                    // updated_at
	CreatedContractAddressHash []byte          `json:"created_contract_address_hash"` // created_contract_address_hash
	FromAddressHash            []byte          `json:"from_address_hash"`             // from_address_hash
	ToAddressHash              []byte          `json:"to_address_hash"`               // to_address_hash
	TransactionHash            []byte          `json:"transaction_hash"`              // transaction_hash
	BlockNumber                sql.NullInt64   `json:"block_number"`                  // block_number
	TransactionIndex           sql.NullInt64   `json:"transaction_index"`             // transaction_index
	BlockHash                  []byte          `json:"block_hash"`                    // block_hash
	BlockIndex                 int             `json:"block_index"`                   // block_index
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the InternalTransaction exists in the database.
func (it *InternalTransaction) Exists() bool {
	return it._exists
}

// Deleted returns true when the InternalTransaction has been marked for deletion from
// the database.
func (it *InternalTransaction) Deleted() bool {
	return it._deleted
}

// Insert inserts the InternalTransaction to the database.
func (it *InternalTransaction) Insert(ctx context.Context, db DB) error {
	switch {
	case it._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case it._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.internal_transactions (` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22` +
		`)`
	// run
	logf(sqlstr, it.CallType, it.CreatedContractCode, it.Error, it.Gas, it.GasUsed, it.Index, it.Init, it.Input, it.Output, it.TraceAddress, it.Type, it.Value, it.InsertedAt, it.UpdatedAt, it.CreatedContractAddressHash, it.FromAddressHash, it.ToAddressHash, it.TransactionHash, it.BlockNumber, it.TransactionIndex, it.BlockHash, it.BlockIndex)
	if _, err := db.ExecContext(ctx, sqlstr, it.CallType, it.CreatedContractCode, it.Error, it.Gas, it.GasUsed, it.Index, it.Init, it.Input, it.Output, it.TraceAddress, it.Type, it.Value, it.InsertedAt, it.UpdatedAt, it.CreatedContractAddressHash, it.FromAddressHash, it.ToAddressHash, it.TransactionHash, it.BlockNumber, it.TransactionIndex, it.BlockHash, it.BlockIndex); err != nil {
		return logerror(err)
	}
	// set exists
	it._exists = true
	return nil
}

// Update updates a InternalTransaction in the database.
func (it *InternalTransaction) Update(ctx context.Context, db DB) error {
	switch {
	case !it._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case it._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.internal_transactions SET ` +
		`call_type = $1, created_contract_code = $2, error = $3, gas = $4, gas_used = $5, index = $6, init = $7, input = $8, output = $9, trace_address = $10, type = $11, value = $12, inserted_at = $13, updated_at = $14, created_contract_address_hash = $15, from_address_hash = $16, to_address_hash = $17, transaction_hash = $18, block_number = $19, transaction_index = $20 ` +
		`WHERE block_hash = $21 AND block_index = $22`
	// run
	logf(sqlstr, it.CallType, it.CreatedContractCode, it.Error, it.Gas, it.GasUsed, it.Index, it.Init, it.Input, it.Output, it.TraceAddress, it.Type, it.Value, it.InsertedAt, it.UpdatedAt, it.CreatedContractAddressHash, it.FromAddressHash, it.ToAddressHash, it.TransactionHash, it.BlockNumber, it.TransactionIndex, it.BlockHash, it.BlockIndex)
	if _, err := db.ExecContext(ctx, sqlstr, it.CallType, it.CreatedContractCode, it.Error, it.Gas, it.GasUsed, it.Index, it.Init, it.Input, it.Output, it.TraceAddress, it.Type, it.Value, it.InsertedAt, it.UpdatedAt, it.CreatedContractAddressHash, it.FromAddressHash, it.ToAddressHash, it.TransactionHash, it.BlockNumber, it.TransactionIndex, it.BlockHash, it.BlockIndex); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the InternalTransaction to the database.
func (it *InternalTransaction) Save(ctx context.Context, db DB) error {
	if it.Exists() {
		return it.Update(ctx, db)
	}
	return it.Insert(ctx, db)
}

// Upsert performs an upsert for InternalTransaction.
func (it *InternalTransaction) Upsert(ctx context.Context, db DB) error {
	switch {
	case it._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.internal_transactions (` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22` +
		`)` +
		` ON CONFLICT (block_hash, block_index) DO ` +
		`UPDATE SET ` +
		`call_type = EXCLUDED.call_type, created_contract_code = EXCLUDED.created_contract_code, error = EXCLUDED.error, gas = EXCLUDED.gas, gas_used = EXCLUDED.gas_used, index = EXCLUDED.index, init = EXCLUDED.init, input = EXCLUDED.input, output = EXCLUDED.output, trace_address = EXCLUDED.trace_address, type = EXCLUDED.type, value = EXCLUDED.value, inserted_at = EXCLUDED.inserted_at, updated_at = EXCLUDED.updated_at, created_contract_address_hash = EXCLUDED.created_contract_address_hash, from_address_hash = EXCLUDED.from_address_hash, to_address_hash = EXCLUDED.to_address_hash, transaction_hash = EXCLUDED.transaction_hash, block_number = EXCLUDED.block_number, transaction_index = EXCLUDED.transaction_index `
	// run
	logf(sqlstr, it.CallType, it.CreatedContractCode, it.Error, it.Gas, it.GasUsed, it.Index, it.Init, it.Input, it.Output, it.TraceAddress, it.Type, it.Value, it.InsertedAt, it.UpdatedAt, it.CreatedContractAddressHash, it.FromAddressHash, it.ToAddressHash, it.TransactionHash, it.BlockNumber, it.TransactionIndex, it.BlockHash, it.BlockIndex)
	if _, err := db.ExecContext(ctx, sqlstr, it.CallType, it.CreatedContractCode, it.Error, it.Gas, it.GasUsed, it.Index, it.Init, it.Input, it.Output, it.TraceAddress, it.Type, it.Value, it.InsertedAt, it.UpdatedAt, it.CreatedContractAddressHash, it.FromAddressHash, it.ToAddressHash, it.TransactionHash, it.BlockNumber, it.TransactionIndex, it.BlockHash, it.BlockIndex); err != nil {
		return logerror(err)
	}
	// set exists
	it._exists = true
	return nil
}

// Delete deletes the InternalTransaction from the database.
func (it *InternalTransaction) Delete(ctx context.Context, db DB) error {
	switch {
	case !it._exists: // doesn't exist
		return nil
	case it._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM public.internal_transactions ` +
		`WHERE block_hash = $1 AND block_index = $2`
	// run
	logf(sqlstr, it.BlockHash, it.BlockIndex)
	if _, err := db.ExecContext(ctx, sqlstr, it.BlockHash, it.BlockIndex); err != nil {
		return logerror(err)
	}
	// set deleted
	it._deleted = true
	return nil
}

// InternalTransactionsByBlockNumberTransactionIndexIndex retrieves a row from 'public.internal_transactions' as a InternalTransaction.
//
// Generated from index 'internal_transactions_block_number_DESC__transaction_index_DESC'.
func InternalTransactionsByBlockNumberTransactionIndexIndex(ctx context.Context, db DB, blockNumber, transactionIndex sql.NullInt64, index int) ([]*InternalTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index ` +
		`FROM public.internal_transactions ` +
		`WHERE block_number = $1 AND transaction_index = $2 AND index = $3`
	// run
	logf(sqlstr, blockNumber, transactionIndex, index)
	rows, err := db.QueryContext(ctx, sqlstr, blockNumber, transactionIndex, index)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*InternalTransaction
	for rows.Next() {
		it := InternalTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&it.CallType, &it.CreatedContractCode, &it.Error, &it.Gas, &it.GasUsed, &it.Index, &it.Init, &it.Input, &it.Output, &it.TraceAddress, &it.Type, &it.Value, &it.InsertedAt, &it.UpdatedAt, &it.CreatedContractAddressHash, &it.FromAddressHash, &it.ToAddressHash, &it.TransactionHash, &it.BlockNumber, &it.TransactionIndex, &it.BlockHash, &it.BlockIndex); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &it)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// InternalTransactionsByCreatedContractAddressHash retrieves a row from 'public.internal_transactions' as a InternalTransaction.
//
// Generated from index 'internal_transactions_created_contract_address_hash_index'.
func InternalTransactionsByCreatedContractAddressHash(ctx context.Context, db DB, createdContractAddressHash []byte) ([]*InternalTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index ` +
		`FROM public.internal_transactions ` +
		`WHERE created_contract_address_hash = $1`
	// run
	logf(sqlstr, createdContractAddressHash)
	rows, err := db.QueryContext(ctx, sqlstr, createdContractAddressHash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*InternalTransaction
	for rows.Next() {
		it := InternalTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&it.CallType, &it.CreatedContractCode, &it.Error, &it.Gas, &it.GasUsed, &it.Index, &it.Init, &it.Input, &it.Output, &it.TraceAddress, &it.Type, &it.Value, &it.InsertedAt, &it.UpdatedAt, &it.CreatedContractAddressHash, &it.FromAddressHash, &it.ToAddressHash, &it.TransactionHash, &it.BlockNumber, &it.TransactionIndex, &it.BlockHash, &it.BlockIndex); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &it)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// InternalTransactionsByCreatedContractAddressHashBlockNumberTransactionIndexIndex retrieves a row from 'public.internal_transactions' as a InternalTransaction.
//
// Generated from index 'internal_transactions_created_contract_address_hash_partial_ind'.
func InternalTransactionsByCreatedContractAddressHashBlockNumberTransactionIndexIndex(ctx context.Context, db DB, createdContractAddressHash []byte, blockNumber, transactionIndex sql.NullInt64, index int) ([]*InternalTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index ` +
		`FROM public.internal_transactions ` +
		`WHERE created_contract_address_hash = $1 AND block_number = $2 AND transaction_index = $3 AND index = $4`
	// run
	logf(sqlstr, createdContractAddressHash, blockNumber, transactionIndex, index)
	rows, err := db.QueryContext(ctx, sqlstr, createdContractAddressHash, blockNumber, transactionIndex, index)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*InternalTransaction
	for rows.Next() {
		it := InternalTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&it.CallType, &it.CreatedContractCode, &it.Error, &it.Gas, &it.GasUsed, &it.Index, &it.Init, &it.Input, &it.Output, &it.TraceAddress, &it.Type, &it.Value, &it.InsertedAt, &it.UpdatedAt, &it.CreatedContractAddressHash, &it.FromAddressHash, &it.ToAddressHash, &it.TransactionHash, &it.BlockNumber, &it.TransactionIndex, &it.BlockHash, &it.BlockIndex); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &it)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// InternalTransactionsByFromAddressHash retrieves a row from 'public.internal_transactions' as a InternalTransaction.
//
// Generated from index 'internal_transactions_from_address_hash_index'.
func InternalTransactionsByFromAddressHash(ctx context.Context, db DB, fromAddressHash []byte) ([]*InternalTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index ` +
		`FROM public.internal_transactions ` +
		`WHERE from_address_hash = $1`
	// run
	logf(sqlstr, fromAddressHash)
	rows, err := db.QueryContext(ctx, sqlstr, fromAddressHash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*InternalTransaction
	for rows.Next() {
		it := InternalTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&it.CallType, &it.CreatedContractCode, &it.Error, &it.Gas, &it.GasUsed, &it.Index, &it.Init, &it.Input, &it.Output, &it.TraceAddress, &it.Type, &it.Value, &it.InsertedAt, &it.UpdatedAt, &it.CreatedContractAddressHash, &it.FromAddressHash, &it.ToAddressHash, &it.TransactionHash, &it.BlockNumber, &it.TransactionIndex, &it.BlockHash, &it.BlockIndex); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &it)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// InternalTransactionsByFromAddressHashBlockNumberTransactionIndexIndex retrieves a row from 'public.internal_transactions' as a InternalTransaction.
//
// Generated from index 'internal_transactions_from_address_hash_partial_index'.
func InternalTransactionsByFromAddressHashBlockNumberTransactionIndexIndex(ctx context.Context, db DB, fromAddressHash []byte, blockNumber, transactionIndex sql.NullInt64, index int) ([]*InternalTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index ` +
		`FROM public.internal_transactions ` +
		`WHERE from_address_hash = $1 AND block_number = $2 AND transaction_index = $3 AND index = $4`
	// run
	logf(sqlstr, fromAddressHash, blockNumber, transactionIndex, index)
	rows, err := db.QueryContext(ctx, sqlstr, fromAddressHash, blockNumber, transactionIndex, index)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*InternalTransaction
	for rows.Next() {
		it := InternalTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&it.CallType, &it.CreatedContractCode, &it.Error, &it.Gas, &it.GasUsed, &it.Index, &it.Init, &it.Input, &it.Output, &it.TraceAddress, &it.Type, &it.Value, &it.InsertedAt, &it.UpdatedAt, &it.CreatedContractAddressHash, &it.FromAddressHash, &it.ToAddressHash, &it.TransactionHash, &it.BlockNumber, &it.TransactionIndex, &it.BlockHash, &it.BlockIndex); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &it)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// InternalTransactionByBlockHashBlockIndex retrieves a row from 'public.internal_transactions' as a InternalTransaction.
//
// Generated from index 'internal_transactions_pkey'.
func InternalTransactionByBlockHashBlockIndex(ctx context.Context, db DB, blockHash []byte, blockIndex int) (*InternalTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index ` +
		`FROM public.internal_transactions ` +
		`WHERE block_hash = $1 AND block_index = $2`
	// run
	logf(sqlstr, blockHash, blockIndex)
	it := InternalTransaction{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, blockHash, blockIndex).Scan(&it.CallType, &it.CreatedContractCode, &it.Error, &it.Gas, &it.GasUsed, &it.Index, &it.Init, &it.Input, &it.Output, &it.TraceAddress, &it.Type, &it.Value, &it.InsertedAt, &it.UpdatedAt, &it.CreatedContractAddressHash, &it.FromAddressHash, &it.ToAddressHash, &it.TransactionHash, &it.BlockNumber, &it.TransactionIndex, &it.BlockHash, &it.BlockIndex); err != nil {
		return nil, logerror(err)
	}
	return &it, nil
}

// InternalTransactionsByToAddressHashBlockNumberTransactionIndexIndex retrieves a row from 'public.internal_transactions' as a InternalTransaction.
//
// Generated from index 'internal_transactions_to_address_hash_partial_index'.
func InternalTransactionsByToAddressHashBlockNumberTransactionIndexIndex(ctx context.Context, db DB, toAddressHash []byte, blockNumber, transactionIndex sql.NullInt64, index int) ([]*InternalTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index ` +
		`FROM public.internal_transactions ` +
		`WHERE to_address_hash = $1 AND block_number = $2 AND transaction_index = $3 AND index = $4`
	// run
	logf(sqlstr, toAddressHash, blockNumber, transactionIndex, index)
	rows, err := db.QueryContext(ctx, sqlstr, toAddressHash, blockNumber, transactionIndex, index)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*InternalTransaction
	for rows.Next() {
		it := InternalTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&it.CallType, &it.CreatedContractCode, &it.Error, &it.Gas, &it.GasUsed, &it.Index, &it.Init, &it.Input, &it.Output, &it.TraceAddress, &it.Type, &it.Value, &it.InsertedAt, &it.UpdatedAt, &it.CreatedContractAddressHash, &it.FromAddressHash, &it.ToAddressHash, &it.TransactionHash, &it.BlockNumber, &it.TransactionIndex, &it.BlockHash, &it.BlockIndex); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &it)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// InternalTransactionsByTransactionHashIndex retrieves a row from 'public.internal_transactions' as a InternalTransaction.
//
// Generated from index 'internal_transactions_transaction_hash_index_index'.
func InternalTransactionsByTransactionHashIndex(ctx context.Context, db DB, transactionHash []byte, index int) ([]*InternalTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`call_type, created_contract_code, error, gas, gas_used, index, init, input, output, trace_address, type, value, inserted_at, updated_at, created_contract_address_hash, from_address_hash, to_address_hash, transaction_hash, block_number, transaction_index, block_hash, block_index ` +
		`FROM public.internal_transactions ` +
		`WHERE transaction_hash = $1 AND index = $2`
	// run
	logf(sqlstr, transactionHash, index)
	rows, err := db.QueryContext(ctx, sqlstr, transactionHash, index)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*InternalTransaction
	for rows.Next() {
		it := InternalTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&it.CallType, &it.CreatedContractCode, &it.Error, &it.Gas, &it.GasUsed, &it.Index, &it.Init, &it.Input, &it.Output, &it.TraceAddress, &it.Type, &it.Value, &it.InsertedAt, &it.UpdatedAt, &it.CreatedContractAddressHash, &it.FromAddressHash, &it.ToAddressHash, &it.TransactionHash, &it.BlockNumber, &it.TransactionIndex, &it.BlockHash, &it.BlockIndex); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &it)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// Block returns the Block associated with the InternalTransaction's (BlockHash).
//
// Generated from foreign key 'internal_transactions_block_hash_fkey'.
func (it *InternalTransaction) Block(ctx context.Context, db DB) (*Block, error) {
	return BlockByHash(ctx, db, it.BlockHash)
}

// Address returns the Address associated with the InternalTransaction's (ToAddressHash).
//
// Generated from foreign key 'internal_transactions_to_address_hash_fkey'.
func (it *InternalTransaction) Address(ctx context.Context, db DB) (*Address, error) {
	return AddressByHash(ctx, db, it.ToAddressHash)
}

// Transaction returns the Transaction associated with the InternalTransaction's (TransactionHash).
//
// Generated from foreign key 'internal_transactions_transaction_hash_fkey'.
func (it *InternalTransaction) Transaction(ctx context.Context, db DB) (*Transaction, error) {
	return TransactionByHash(ctx, db, it.TransactionHash)
}
