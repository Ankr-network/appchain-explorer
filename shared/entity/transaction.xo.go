package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// Transaction represents a row from 'public.transactions'.
type Transaction struct {
	CumulativeGasUsed            sql.NullFloat64 `json:"cumulative_gas_used"`              // cumulative_gas_used
	Error                        sql.NullString  `json:"error"`                            // error
	Gas                          float64         `json:"gas"`                              // gas
	GasPrice                     float64         `json:"gas_price"`                        // gas_price
	GasUsed                      sql.NullFloat64 `json:"gas_used"`                         // gas_used
	Hash                         []byte          `json:"hash"`                             // hash
	Index                        sql.NullInt64   `json:"index"`                            // index
	Input                        []byte          `json:"input"`                            // input
	Nonce                        int             `json:"nonce"`                            // nonce
	R                            float64         `json:"r"`                                // r
	S                            float64         `json:"s"`                                // s
	Status                       sql.NullInt64   `json:"status"`                           // status
	V                            float64         `json:"v"`                                // v
	Value                        float64         `json:"value"`                            // value
	InsertedAt                   time.Time       `json:"inserted_at"`                      // inserted_at
	UpdatedAt                    time.Time       `json:"updated_at"`                       // updated_at
	BlockHash                    []byte          `json:"block_hash"`                       // block_hash
	BlockNumber                  sql.NullInt64   `json:"block_number"`                     // block_number
	FromAddressHash              []byte          `json:"from_address_hash"`                // from_address_hash
	ToAddressHash                []byte          `json:"to_address_hash"`                  // to_address_hash
	CreatedContractAddressHash   []byte          `json:"created_contract_address_hash"`    // created_contract_address_hash
	CreatedContractCodeIndexedAt sql.NullTime    `json:"created_contract_code_indexed_at"` // created_contract_code_indexed_at
	EarliestProcessingStart      sql.NullTime    `json:"earliest_processing_start"`        // earliest_processing_start
	OldBlockHash                 []byte          `json:"old_block_hash"`                   // old_block_hash
	RevertReason                 sql.NullString  `json:"revert_reason"`                    // revert_reason
	MaxPriorityFeePerGas         sql.NullFloat64 `json:"max_priority_fee_per_gas"`         // max_priority_fee_per_gas
	MaxFeePerGas                 sql.NullFloat64 `json:"max_fee_per_gas"`                  // max_fee_per_gas
	Type                         sql.NullInt64   `json:"type"`                             // type
	HasErrorInInternalTxs        sql.NullBool    `json:"has_error_in_internal_txs"`        // has_error_in_internal_txs
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Transaction exists in the database.
func (t *Transaction) Exists() bool {
	return t._exists
}

// Deleted returns true when the Transaction has been marked for deletion from
// the database.
func (t *Transaction) Deleted() bool {
	return t._deleted
}

// Insert inserts the Transaction to the database.
func (t *Transaction) Insert(ctx context.Context, db DB) error {
	switch {
	case t._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case t._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.transactions (` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29` +
		`)`
	// run
	logf(sqlstr, t.CumulativeGasUsed, t.Error, t.Gas, t.GasPrice, t.GasUsed, t.Hash, t.Index, t.Input, t.Nonce, t.R, t.S, t.Status, t.V, t.Value, t.InsertedAt, t.UpdatedAt, t.BlockHash, t.BlockNumber, t.FromAddressHash, t.ToAddressHash, t.CreatedContractAddressHash, t.CreatedContractCodeIndexedAt, t.EarliestProcessingStart, t.OldBlockHash, t.RevertReason, t.MaxPriorityFeePerGas, t.MaxFeePerGas, t.Type, t.HasErrorInInternalTxs)
	if _, err := db.ExecContext(ctx, sqlstr, t.CumulativeGasUsed, t.Error, t.Gas, t.GasPrice, t.GasUsed, t.Hash, t.Index, t.Input, t.Nonce, t.R, t.S, t.Status, t.V, t.Value, t.InsertedAt, t.UpdatedAt, t.BlockHash, t.BlockNumber, t.FromAddressHash, t.ToAddressHash, t.CreatedContractAddressHash, t.CreatedContractCodeIndexedAt, t.EarliestProcessingStart, t.OldBlockHash, t.RevertReason, t.MaxPriorityFeePerGas, t.MaxFeePerGas, t.Type, t.HasErrorInInternalTxs); err != nil {
		return logerror(err)
	}
	// set exists
	t._exists = true
	return nil
}

// Update updates a Transaction in the database.
func (t *Transaction) Update(ctx context.Context, db DB) error {
	switch {
	case !t._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case t._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.transactions SET ` +
		`cumulative_gas_used = $1, error = $2, gas = $3, gas_price = $4, gas_used = $5, index = $6, input = $7, nonce = $8, r = $9, s = $10, status = $11, v = $12, value = $13, inserted_at = $14, updated_at = $15, block_hash = $16, block_number = $17, from_address_hash = $18, to_address_hash = $19, created_contract_address_hash = $20, created_contract_code_indexed_at = $21, earliest_processing_start = $22, old_block_hash = $23, revert_reason = $24, max_priority_fee_per_gas = $25, max_fee_per_gas = $26, type = $27, has_error_in_internal_txs = $28 ` +
		`WHERE hash = $29`
	// run
	logf(sqlstr, t.CumulativeGasUsed, t.Error, t.Gas, t.GasPrice, t.GasUsed, t.Index, t.Input, t.Nonce, t.R, t.S, t.Status, t.V, t.Value, t.InsertedAt, t.UpdatedAt, t.BlockHash, t.BlockNumber, t.FromAddressHash, t.ToAddressHash, t.CreatedContractAddressHash, t.CreatedContractCodeIndexedAt, t.EarliestProcessingStart, t.OldBlockHash, t.RevertReason, t.MaxPriorityFeePerGas, t.MaxFeePerGas, t.Type, t.HasErrorInInternalTxs, t.Hash)
	if _, err := db.ExecContext(ctx, sqlstr, t.CumulativeGasUsed, t.Error, t.Gas, t.GasPrice, t.GasUsed, t.Index, t.Input, t.Nonce, t.R, t.S, t.Status, t.V, t.Value, t.InsertedAt, t.UpdatedAt, t.BlockHash, t.BlockNumber, t.FromAddressHash, t.ToAddressHash, t.CreatedContractAddressHash, t.CreatedContractCodeIndexedAt, t.EarliestProcessingStart, t.OldBlockHash, t.RevertReason, t.MaxPriorityFeePerGas, t.MaxFeePerGas, t.Type, t.HasErrorInInternalTxs, t.Hash); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Transaction to the database.
func (t *Transaction) Save(ctx context.Context, db DB) error {
	if t.Exists() {
		return t.Update(ctx, db)
	}
	return t.Insert(ctx, db)
}

// Upsert performs an upsert for Transaction.
func (t *Transaction) Upsert(ctx context.Context, db DB) error {
	switch {
	case t._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.transactions (` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29` +
		`)` +
		` ON CONFLICT (hash) DO ` +
		`UPDATE SET ` +
		`cumulative_gas_used = EXCLUDED.cumulative_gas_used, error = EXCLUDED.error, gas = EXCLUDED.gas, gas_price = EXCLUDED.gas_price, gas_used = EXCLUDED.gas_used, index = EXCLUDED.index, input = EXCLUDED.input, nonce = EXCLUDED.nonce, r = EXCLUDED.r, s = EXCLUDED.s, status = EXCLUDED.status, v = EXCLUDED.v, value = EXCLUDED.value, inserted_at = EXCLUDED.inserted_at, updated_at = EXCLUDED.updated_at, block_hash = EXCLUDED.block_hash, block_number = EXCLUDED.block_number, from_address_hash = EXCLUDED.from_address_hash, to_address_hash = EXCLUDED.to_address_hash, created_contract_address_hash = EXCLUDED.created_contract_address_hash, created_contract_code_indexed_at = EXCLUDED.created_contract_code_indexed_at, earliest_processing_start = EXCLUDED.earliest_processing_start, old_block_hash = EXCLUDED.old_block_hash, revert_reason = EXCLUDED.revert_reason, max_priority_fee_per_gas = EXCLUDED.max_priority_fee_per_gas, max_fee_per_gas = EXCLUDED.max_fee_per_gas, type = EXCLUDED.type, has_error_in_internal_txs = EXCLUDED.has_error_in_internal_txs `
	// run
	logf(sqlstr, t.CumulativeGasUsed, t.Error, t.Gas, t.GasPrice, t.GasUsed, t.Hash, t.Index, t.Input, t.Nonce, t.R, t.S, t.Status, t.V, t.Value, t.InsertedAt, t.UpdatedAt, t.BlockHash, t.BlockNumber, t.FromAddressHash, t.ToAddressHash, t.CreatedContractAddressHash, t.CreatedContractCodeIndexedAt, t.EarliestProcessingStart, t.OldBlockHash, t.RevertReason, t.MaxPriorityFeePerGas, t.MaxFeePerGas, t.Type, t.HasErrorInInternalTxs)
	if _, err := db.ExecContext(ctx, sqlstr, t.CumulativeGasUsed, t.Error, t.Gas, t.GasPrice, t.GasUsed, t.Hash, t.Index, t.Input, t.Nonce, t.R, t.S, t.Status, t.V, t.Value, t.InsertedAt, t.UpdatedAt, t.BlockHash, t.BlockNumber, t.FromAddressHash, t.ToAddressHash, t.CreatedContractAddressHash, t.CreatedContractCodeIndexedAt, t.EarliestProcessingStart, t.OldBlockHash, t.RevertReason, t.MaxPriorityFeePerGas, t.MaxFeePerGas, t.Type, t.HasErrorInInternalTxs); err != nil {
		return logerror(err)
	}
	// set exists
	t._exists = true
	return nil
}

// Delete deletes the Transaction from the database.
func (t *Transaction) Delete(ctx context.Context, db DB) error {
	switch {
	case !t._exists: // doesn't exist
		return nil
	case t._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.transactions ` +
		`WHERE hash = $1`
	// run
	logf(sqlstr, t.Hash)
	if _, err := db.ExecContext(ctx, sqlstr, t.Hash); err != nil {
		return logerror(err)
	}
	// set deleted
	t._deleted = true
	return nil
}

// TransactionsByInsertedAtHash retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'pending_txs_index'.
func TransactionsByInsertedAtHash(ctx context.Context, db DB, insertedAt time.Time, hash []byte) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE inserted_at = $1 AND hash = $2`
	// run
	logf(sqlstr, insertedAt, hash)
	rows, err := db.QueryContext(ctx, sqlstr, insertedAt, hash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByBlockHashError retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_block_hash_error_index'.
func TransactionsByBlockHashError(ctx context.Context, db DB, blockHash []byte, e sql.NullString) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE block_hash = $1 AND error = $2`
	// run
	logf(sqlstr, blockHash, e)
	rows, err := db.QueryContext(ctx, sqlstr, blockHash, e)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionByBlockHashIndex retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_block_hash_index_index'.
func TransactionByBlockHashIndex(ctx context.Context, db DB, blockHash []byte, index sql.NullInt64) (*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE block_hash = $1 AND index = $2`
	// run
	logf(sqlstr, blockHash, index)
	t := Transaction{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, blockHash, index).Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
		return nil, logerror(err)
	}
	return &t, nil
}

// TransactionsByBlockNumber retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_block_number_index'.
func TransactionsByBlockNumber(ctx context.Context, db DB, blockNumber sql.NullInt64) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE block_number = $1`
	// run
	logf(sqlstr, blockNumber)
	rows, err := db.QueryContext(ctx, sqlstr, blockNumber)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByCreatedContractAddressHashBlockNumberIndexHash retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_created_contract_address_hash_recent_collated_inde'.
func TransactionsByCreatedContractAddressHashBlockNumberIndexHash(ctx context.Context, db DB, createdContractAddressHash []byte, blockNumber, index sql.NullInt64, hash []byte) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE created_contract_address_hash = $1 AND block_number = $2 AND index = $3 AND hash = $4`
	// run
	logf(sqlstr, createdContractAddressHash, blockNumber, index, hash)
	rows, err := db.QueryContext(ctx, sqlstr, createdContractAddressHash, blockNumber, index, hash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByCreatedContractCodeIndexedAt retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_created_contract_code_indexed_at_index'.
func TransactionsByCreatedContractCodeIndexedAt(ctx context.Context, db DB, createdContractCodeIndexedAt sql.NullTime) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE created_contract_code_indexed_at = $1`
	// run
	logf(sqlstr, createdContractCodeIndexedAt)
	rows, err := db.QueryContext(ctx, sqlstr, createdContractCodeIndexedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByFromAddressHashBlockNumberIndexHash retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_from_address_hash_recent_collated_index'.
func TransactionsByFromAddressHashBlockNumberIndexHash(ctx context.Context, db DB, fromAddressHash []byte, blockNumber, index sql.NullInt64, hash []byte) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE from_address_hash = $1 AND block_number = $2 AND index = $3 AND hash = $4`
	// run
	logf(sqlstr, fromAddressHash, blockNumber, index, hash)
	rows, err := db.QueryContext(ctx, sqlstr, fromAddressHash, blockNumber, index, hash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByInsertedAt retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_inserted_at_index'.
func TransactionsByInsertedAt(ctx context.Context, db DB, insertedAt time.Time) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE inserted_at = $1`
	// run
	logf(sqlstr, insertedAt)
	rows, err := db.QueryContext(ctx, sqlstr, insertedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByNonceFromAddressHashBlockHash retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_nonce_from_address_hash_block_hash_index'.
func TransactionsByNonceFromAddressHashBlockHash(ctx context.Context, db DB, nonce int, fromAddressHash, blockHash []byte) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE nonce = $1 AND from_address_hash = $2 AND block_hash = $3`
	// run
	logf(sqlstr, nonce, fromAddressHash, blockHash)
	rows, err := db.QueryContext(ctx, sqlstr, nonce, fromAddressHash, blockHash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionByHash retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_pkey'.
func TransactionByHash(ctx context.Context, db DB, hash []byte) (*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE hash = $1`
	// run
	logf(sqlstr, hash)
	t := Transaction{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, hash).Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
		return nil, logerror(err)
	}
	return &t, nil
}

// TransactionsByBlockNumberIndex retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_recent_collated_index'.
func TransactionsByBlockNumberIndex(ctx context.Context, db DB, blockNumber, index sql.NullInt64) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE block_number = $1 AND index = $2`
	// run
	logf(sqlstr, blockNumber, index)
	rows, err := db.QueryContext(ctx, sqlstr, blockNumber, index)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByStatus retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_status_index'.
func TransactionsByStatus(ctx context.Context, db DB, status sql.NullInt64) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE status = $1`
	// run
	logf(sqlstr, status)
	rows, err := db.QueryContext(ctx, sqlstr, status)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByToAddressHashBlockNumberIndexHash retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_to_address_hash_recent_collated_index'.
func TransactionsByToAddressHashBlockNumberIndexHash(ctx context.Context, db DB, toAddressHash []byte, blockNumber, index sql.NullInt64, hash []byte) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE to_address_hash = $1 AND block_number = $2 AND index = $3 AND hash = $4`
	// run
	logf(sqlstr, toAddressHash, blockNumber, index, hash)
	rows, err := db.QueryContext(ctx, sqlstr, toAddressHash, blockNumber, index, hash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// TransactionsByUpdatedAt retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_updated_at_index'.
func TransactionsByUpdatedAt(ctx context.Context, db DB, updatedAt time.Time) ([]*Transaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`cumulative_gas_used, error, gas, gas_price, gas_used, hash, index, input, nonce, r, s, status, v, value, inserted_at, updated_at, block_hash, block_number, from_address_hash, to_address_hash, created_contract_address_hash, created_contract_code_indexed_at, earliest_processing_start, old_block_hash, revert_reason, max_priority_fee_per_gas, max_fee_per_gas, type, has_error_in_internal_txs ` +
		`FROM public.transactions ` +
		`WHERE updated_at = $1`
	// run
	logf(sqlstr, updatedAt)
	rows, err := db.QueryContext(ctx, sqlstr, updatedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Transaction
	for rows.Next() {
		t := Transaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&t.CumulativeGasUsed, &t.Error, &t.Gas, &t.GasPrice, &t.GasUsed, &t.Hash, &t.Index, &t.Input, &t.Nonce, &t.R, &t.S, &t.Status, &t.V, &t.Value, &t.InsertedAt, &t.UpdatedAt, &t.BlockHash, &t.BlockNumber, &t.FromAddressHash, &t.ToAddressHash, &t.CreatedContractAddressHash, &t.CreatedContractCodeIndexedAt, &t.EarliestProcessingStart, &t.OldBlockHash, &t.RevertReason, &t.MaxPriorityFeePerGas, &t.MaxFeePerGas, &t.Type, &t.HasErrorInInternalTxs); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &t)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// Block returns the Block associated with the Transaction's (BlockHash).
//
// Generated from foreign key 'transactions_block_hash_fkey'.
func (t *Transaction) Block(ctx context.Context, db DB) (*Block, error) {
	return BlockByHash(ctx, db, t.BlockHash)
}

// Address returns the Address associated with the Transaction's (ToAddressHash).
//
// Generated from foreign key 'transactions_to_address_hash_fkey'.
func (t *Transaction) Address(ctx context.Context, db DB) (*Address, error) {
	return AddressByHash(ctx, db, t.ToAddressHash)
}
