package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"time"
)

// ContractVerificationStatus represents a row from 'public.contract_verification_status'.
type ContractVerificationStatus struct {
	UID         string    `json:"uid"`          // uid
	Status      int16     `json:"status"`       // status
	AddressHash []byte    `json:"address_hash"` // address_hash
	InsertedAt  time.Time `json:"inserted_at"`  // inserted_at
	UpdatedAt   time.Time `json:"updated_at"`   // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the ContractVerificationStatus exists in the database.
func (cvs *ContractVerificationStatus) Exists() bool {
	return cvs._exists
}

// Deleted returns true when the ContractVerificationStatus has been marked for deletion from
// the database.
func (cvs *ContractVerificationStatus) Deleted() bool {
	return cvs._deleted
}

// Insert inserts the ContractVerificationStatus to the database.
func (cvs *ContractVerificationStatus) Insert(ctx context.Context, db DB) error {
	switch {
	case cvs._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case cvs._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.contract_verification_status (` +
		`uid, status, address_hash, inserted_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)`
	// run
	logf(sqlstr, cvs.UID, cvs.Status, cvs.AddressHash, cvs.InsertedAt, cvs.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, cvs.UID, cvs.Status, cvs.AddressHash, cvs.InsertedAt, cvs.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	cvs._exists = true
	return nil
}

// Update updates a ContractVerificationStatus in the database.
func (cvs *ContractVerificationStatus) Update(ctx context.Context, db DB) error {
	switch {
	case !cvs._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case cvs._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.contract_verification_status SET ` +
		`status = $1, address_hash = $2, inserted_at = $3, updated_at = $4 ` +
		`WHERE uid = $5`
	// run
	logf(sqlstr, cvs.Status, cvs.AddressHash, cvs.InsertedAt, cvs.UpdatedAt, cvs.UID)
	if _, err := db.ExecContext(ctx, sqlstr, cvs.Status, cvs.AddressHash, cvs.InsertedAt, cvs.UpdatedAt, cvs.UID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the ContractVerificationStatus to the database.
func (cvs *ContractVerificationStatus) Save(ctx context.Context, db DB) error {
	if cvs.Exists() {
		return cvs.Update(ctx, db)
	}
	return cvs.Insert(ctx, db)
}

// Upsert performs an upsert for ContractVerificationStatus.
func (cvs *ContractVerificationStatus) Upsert(ctx context.Context, db DB) error {
	switch {
	case cvs._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.contract_verification_status (` +
		`uid, status, address_hash, inserted_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (uid) DO ` +
		`UPDATE SET ` +
		`status = EXCLUDED.status, address_hash = EXCLUDED.address_hash, inserted_at = EXCLUDED.inserted_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, cvs.UID, cvs.Status, cvs.AddressHash, cvs.InsertedAt, cvs.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, cvs.UID, cvs.Status, cvs.AddressHash, cvs.InsertedAt, cvs.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	cvs._exists = true
	return nil
}

// Delete deletes the ContractVerificationStatus from the database.
func (cvs *ContractVerificationStatus) Delete(ctx context.Context, db DB) error {
	switch {
	case !cvs._exists: // doesn't exist
		return nil
	case cvs._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.contract_verification_status ` +
		`WHERE uid = $1`
	// run
	logf(sqlstr, cvs.UID)
	if _, err := db.ExecContext(ctx, sqlstr, cvs.UID); err != nil {
		return logerror(err)
	}
	// set deleted
	cvs._deleted = true
	return nil
}

// ContractVerificationStatusByUID retrieves a row from 'public.contract_verification_status' as a ContractVerificationStatus.
//
// Generated from index 'contract_verification_status_pkey'.
func ContractVerificationStatusByUID(ctx context.Context, db DB, uid string) (*ContractVerificationStatus, error) {
	// query
	const sqlstr = `SELECT ` +
		`uid, status, address_hash, inserted_at, updated_at ` +
		`FROM public.contract_verification_status ` +
		`WHERE uid = $1`
	// run
	logf(sqlstr, uid)
	cvs := ContractVerificationStatus{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, uid).Scan(&cvs.UID, &cvs.Status, &cvs.AddressHash, &cvs.InsertedAt, &cvs.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &cvs, nil
}
