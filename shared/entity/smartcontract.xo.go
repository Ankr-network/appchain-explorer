package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// SmartContract represents a row from 'public.smart_contracts'.
type SmartContract struct {
	ID                   int64          `json:"id"`                    // id
	Name                 string         `json:"name"`                  // name
	CompilerVersion      string         `json:"compiler_version"`      // compiler_version
	Optimization         bool           `json:"optimization"`          // optimization
	ContractSourceCode   string         `json:"contract_source_code"`  // contract_source_code
	Abi                  []byte         `json:"abi"`                   // abi
	AddressHash          []byte         `json:"address_hash"`          // address_hash
	InsertedAt           time.Time      `json:"inserted_at"`           // inserted_at
	UpdatedAt            time.Time      `json:"updated_at"`            // updated_at
	ConstructorArguments sql.NullString `json:"constructor_arguments"` // constructor_arguments
	OptimizationRuns     sql.NullInt64  `json:"optimization_runs"`     // optimization_runs
	EvmVersion           sql.NullString `json:"evm_version"`           // evm_version
	ExternalLibraries    [][]byte       `json:"external_libraries"`    // external_libraries
	VerifiedViaSourcify  sql.NullBool   `json:"verified_via_sourcify"` // verified_via_sourcify
	IsVyperContract      sql.NullBool   `json:"is_vyper_contract"`     // is_vyper_contract
	PartiallyVerified    sql.NullBool   `json:"partially_verified"`    // partially_verified
	FilePath             sql.NullString `json:"file_path"`             // file_path
	IsChangedBytecode    sql.NullBool   `json:"is_changed_bytecode"`   // is_changed_bytecode
	BytecodeCheckedAt    sql.NullTime   `json:"bytecode_checked_at"`   // bytecode_checked_at
	ContractCodeMd5      string         `json:"contract_code_md5"`     // contract_code_md5
	ImplementationName   sql.NullString `json:"implementation_name"`   // implementation_name
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the SmartContract exists in the database.
func (sc *SmartContract) Exists() bool {
	return sc._exists
}

// Deleted returns true when the SmartContract has been marked for deletion from
// the database.
func (sc *SmartContract) Deleted() bool {
	return sc._deleted
}

// Insert inserts the SmartContract to the database.
func (sc *SmartContract) Insert(ctx context.Context, db DB) error {
	switch {
	case sc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case sc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.smart_contracts (` +
		`name, compiler_version, optimization, contract_source_code, abi, address_hash, inserted_at, updated_at, constructor_arguments, optimization_runs, evm_version, external_libraries, verified_via_sourcify, is_vyper_contract, partially_verified, file_path, is_changed_bytecode, bytecode_checked_at, contract_code_md5, implementation_name` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20` +
		`) RETURNING id`
	// run
	logf(sqlstr, sc.Name, sc.CompilerVersion, sc.Optimization, sc.ContractSourceCode, sc.Abi, sc.AddressHash, sc.InsertedAt, sc.UpdatedAt, sc.ConstructorArguments, sc.OptimizationRuns, sc.EvmVersion, sc.ExternalLibraries, sc.VerifiedViaSourcify, sc.IsVyperContract, sc.PartiallyVerified, sc.FilePath, sc.IsChangedBytecode, sc.BytecodeCheckedAt, sc.ContractCodeMd5, sc.ImplementationName)
	if err := db.QueryRowContext(ctx, sqlstr, sc.Name, sc.CompilerVersion, sc.Optimization, sc.ContractSourceCode, sc.Abi, sc.AddressHash, sc.InsertedAt, sc.UpdatedAt, sc.ConstructorArguments, sc.OptimizationRuns, sc.EvmVersion, sc.ExternalLibraries, sc.VerifiedViaSourcify, sc.IsVyperContract, sc.PartiallyVerified, sc.FilePath, sc.IsChangedBytecode, sc.BytecodeCheckedAt, sc.ContractCodeMd5, sc.ImplementationName).Scan(&sc.ID); err != nil {
		return logerror(err)
	}
	// set exists
	sc._exists = true
	return nil
}

// Update updates a SmartContract in the database.
func (sc *SmartContract) Update(ctx context.Context, db DB) error {
	switch {
	case !sc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case sc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.smart_contracts SET ` +
		`name = $1, compiler_version = $2, optimization = $3, contract_source_code = $4, abi = $5, address_hash = $6, inserted_at = $7, updated_at = $8, constructor_arguments = $9, optimization_runs = $10, evm_version = $11, external_libraries = $12, verified_via_sourcify = $13, is_vyper_contract = $14, partially_verified = $15, file_path = $16, is_changed_bytecode = $17, bytecode_checked_at = $18, contract_code_md5 = $19, implementation_name = $20 ` +
		`WHERE id = $21`
	// run
	logf(sqlstr, sc.Name, sc.CompilerVersion, sc.Optimization, sc.ContractSourceCode, sc.Abi, sc.AddressHash, sc.InsertedAt, sc.UpdatedAt, sc.ConstructorArguments, sc.OptimizationRuns, sc.EvmVersion, sc.ExternalLibraries, sc.VerifiedViaSourcify, sc.IsVyperContract, sc.PartiallyVerified, sc.FilePath, sc.IsChangedBytecode, sc.BytecodeCheckedAt, sc.ContractCodeMd5, sc.ImplementationName, sc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, sc.Name, sc.CompilerVersion, sc.Optimization, sc.ContractSourceCode, sc.Abi, sc.AddressHash, sc.InsertedAt, sc.UpdatedAt, sc.ConstructorArguments, sc.OptimizationRuns, sc.EvmVersion, sc.ExternalLibraries, sc.VerifiedViaSourcify, sc.IsVyperContract, sc.PartiallyVerified, sc.FilePath, sc.IsChangedBytecode, sc.BytecodeCheckedAt, sc.ContractCodeMd5, sc.ImplementationName, sc.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the SmartContract to the database.
func (sc *SmartContract) Save(ctx context.Context, db DB) error {
	if sc.Exists() {
		return sc.Update(ctx, db)
	}
	return sc.Insert(ctx, db)
}

// Upsert performs an upsert for SmartContract.
func (sc *SmartContract) Upsert(ctx context.Context, db DB) error {
	switch {
	case sc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.smart_contracts (` +
		`id, name, compiler_version, optimization, contract_source_code, abi, address_hash, inserted_at, updated_at, constructor_arguments, optimization_runs, evm_version, external_libraries, verified_via_sourcify, is_vyper_contract, partially_verified, file_path, is_changed_bytecode, bytecode_checked_at, contract_code_md5, implementation_name` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`name = EXCLUDED.name, compiler_version = EXCLUDED.compiler_version, optimization = EXCLUDED.optimization, contract_source_code = EXCLUDED.contract_source_code, abi = EXCLUDED.abi, address_hash = EXCLUDED.address_hash, inserted_at = EXCLUDED.inserted_at, updated_at = EXCLUDED.updated_at, constructor_arguments = EXCLUDED.constructor_arguments, optimization_runs = EXCLUDED.optimization_runs, evm_version = EXCLUDED.evm_version, external_libraries = EXCLUDED.external_libraries, verified_via_sourcify = EXCLUDED.verified_via_sourcify, is_vyper_contract = EXCLUDED.is_vyper_contract, partially_verified = EXCLUDED.partially_verified, file_path = EXCLUDED.file_path, is_changed_bytecode = EXCLUDED.is_changed_bytecode, bytecode_checked_at = EXCLUDED.bytecode_checked_at, contract_code_md5 = EXCLUDED.contract_code_md5, implementation_name = EXCLUDED.implementation_name `
	// run
	logf(sqlstr, sc.ID, sc.Name, sc.CompilerVersion, sc.Optimization, sc.ContractSourceCode, sc.Abi, sc.AddressHash, sc.InsertedAt, sc.UpdatedAt, sc.ConstructorArguments, sc.OptimizationRuns, sc.EvmVersion, sc.ExternalLibraries, sc.VerifiedViaSourcify, sc.IsVyperContract, sc.PartiallyVerified, sc.FilePath, sc.IsChangedBytecode, sc.BytecodeCheckedAt, sc.ContractCodeMd5, sc.ImplementationName)
	if _, err := db.ExecContext(ctx, sqlstr, sc.ID, sc.Name, sc.CompilerVersion, sc.Optimization, sc.ContractSourceCode, sc.Abi, sc.AddressHash, sc.InsertedAt, sc.UpdatedAt, sc.ConstructorArguments, sc.OptimizationRuns, sc.EvmVersion, sc.ExternalLibraries, sc.VerifiedViaSourcify, sc.IsVyperContract, sc.PartiallyVerified, sc.FilePath, sc.IsChangedBytecode, sc.BytecodeCheckedAt, sc.ContractCodeMd5, sc.ImplementationName); err != nil {
		return logerror(err)
	}
	// set exists
	sc._exists = true
	return nil
}

// Delete deletes the SmartContract from the database.
func (sc *SmartContract) Delete(ctx context.Context, db DB) error {
	switch {
	case !sc._exists: // doesn't exist
		return nil
	case sc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.smart_contracts ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, sc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, sc.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	sc._deleted = true
	return nil
}

// SmartContractByAddressHash retrieves a row from 'public.smart_contracts' as a SmartContract.
//
// Generated from index 'smart_contracts_address_hash_index'.
func SmartContractByAddressHash(ctx context.Context, db DB, addressHash []byte) (*SmartContract, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, name, compiler_version, optimization, contract_source_code, abi, address_hash, inserted_at, updated_at, constructor_arguments, optimization_runs, evm_version, external_libraries, verified_via_sourcify, is_vyper_contract, partially_verified, file_path, is_changed_bytecode, bytecode_checked_at, contract_code_md5, implementation_name ` +
		`FROM public.smart_contracts ` +
		`WHERE address_hash = $1`
	// run
	logf(sqlstr, addressHash)
	sc := SmartContract{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, addressHash).Scan(&sc.ID, &sc.Name, &sc.CompilerVersion, &sc.Optimization, &sc.ContractSourceCode, &sc.Abi, &sc.AddressHash, &sc.InsertedAt, &sc.UpdatedAt, &sc.ConstructorArguments, &sc.OptimizationRuns, &sc.EvmVersion, &sc.ExternalLibraries, &sc.VerifiedViaSourcify, &sc.IsVyperContract, &sc.PartiallyVerified, &sc.FilePath, &sc.IsChangedBytecode, &sc.BytecodeCheckedAt, &sc.ContractCodeMd5, &sc.ImplementationName); err != nil {
		return nil, logerror(err)
	}
	return &sc, nil
}

// SmartContractsByContractCodeMd5 retrieves a row from 'public.smart_contracts' as a SmartContract.
//
// Generated from index 'smart_contracts_contract_code_md5_index'.
func SmartContractsByContractCodeMd5(ctx context.Context, db DB, contractCodeMd5 string) ([]*SmartContract, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, name, compiler_version, optimization, contract_source_code, abi, address_hash, inserted_at, updated_at, constructor_arguments, optimization_runs, evm_version, external_libraries, verified_via_sourcify, is_vyper_contract, partially_verified, file_path, is_changed_bytecode, bytecode_checked_at, contract_code_md5, implementation_name ` +
		`FROM public.smart_contracts ` +
		`WHERE contract_code_md5 = $1`
	// run
	logf(sqlstr, contractCodeMd5)
	rows, err := db.QueryContext(ctx, sqlstr, contractCodeMd5)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*SmartContract
	for rows.Next() {
		sc := SmartContract{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&sc.ID, &sc.Name, &sc.CompilerVersion, &sc.Optimization, &sc.ContractSourceCode, &sc.Abi, &sc.AddressHash, &sc.InsertedAt, &sc.UpdatedAt, &sc.ConstructorArguments, &sc.OptimizationRuns, &sc.EvmVersion, &sc.ExternalLibraries, &sc.VerifiedViaSourcify, &sc.IsVyperContract, &sc.PartiallyVerified, &sc.FilePath, &sc.IsChangedBytecode, &sc.BytecodeCheckedAt, &sc.ContractCodeMd5, &sc.ImplementationName); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &sc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// SmartContractByID retrieves a row from 'public.smart_contracts' as a SmartContract.
//
// Generated from index 'smart_contracts_pkey'.
func SmartContractByID(ctx context.Context, db DB, id int64) (*SmartContract, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, name, compiler_version, optimization, contract_source_code, abi, address_hash, inserted_at, updated_at, constructor_arguments, optimization_runs, evm_version, external_libraries, verified_via_sourcify, is_vyper_contract, partially_verified, file_path, is_changed_bytecode, bytecode_checked_at, contract_code_md5, implementation_name ` +
		`FROM public.smart_contracts ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	sc := SmartContract{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&sc.ID, &sc.Name, &sc.CompilerVersion, &sc.Optimization, &sc.ContractSourceCode, &sc.Abi, &sc.AddressHash, &sc.InsertedAt, &sc.UpdatedAt, &sc.ConstructorArguments, &sc.OptimizationRuns, &sc.EvmVersion, &sc.ExternalLibraries, &sc.VerifiedViaSourcify, &sc.IsVyperContract, &sc.PartiallyVerified, &sc.FilePath, &sc.IsChangedBytecode, &sc.BytecodeCheckedAt, &sc.ContractCodeMd5, &sc.ImplementationName); err != nil {
		return nil, logerror(err)
	}
	return &sc, nil
}

// Address returns the Address associated with the SmartContract's (AddressHash).
//
// Generated from foreign key 'smart_contracts_address_hash_fkey'.
func (sc *SmartContract) Address(ctx context.Context, db DB) (*Address, error) {
	return AddressByHash(ctx, db, sc.AddressHash)
}
