// Package entity contains generated code for schema 'public'.
package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// Address represents a row from 'public.addresses'.
type Address struct {
	FetchedCoinBalance            sql.NullFloat64 `json:"fetched_coin_balance"`              // fetched_coin_balance
	FetchedCoinBalanceBlockNumber sql.NullInt64   `json:"fetched_coin_balance_block_number"` // fetched_coin_balance_block_number
	Hash                          []byte          `json:"hash"`                              // hash
	ContractCode                  []byte          `json:"contract_code"`                     // contract_code
	InsertedAt                    time.Time       `json:"inserted_at"`                       // inserted_at
	UpdatedAt                     time.Time       `json:"updated_at"`                        // updated_at
	Nonce                         sql.NullInt64   `json:"nonce"`                             // nonce
	Decompiled                    sql.NullBool    `json:"decompiled"`                        // decompiled
	Verified                      sql.NullBool    `json:"verified"`                          // verified
	GasUsed                       sql.NullInt64   `json:"gas_used"`                          // gas_used
	TransactionsCount             sql.NullInt64   `json:"transactions_count"`                // transactions_count
	TokenTransfersCount           sql.NullInt64   `json:"token_transfers_count"`             // token_transfers_count
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Address exists in the database.
func (a *Address) Exists() bool {
	return a._exists
}

// Deleted returns true when the Address has been marked for deletion from
// the database.
func (a *Address) Deleted() bool {
	return a._deleted
}

// Insert inserts the Address to the database.
func (a *Address) Insert(ctx context.Context, db DB) error {
	switch {
	case a._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case a._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.addresses (` +
		`fetched_coin_balance, fetched_coin_balance_block_number, hash, contract_code, inserted_at, updated_at, nonce, decompiled, verified, gas_used, transactions_count, token_transfers_count` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12` +
		`)`
	// run
	logf(sqlstr, a.FetchedCoinBalance, a.FetchedCoinBalanceBlockNumber, a.Hash, a.ContractCode, a.InsertedAt, a.UpdatedAt, a.Nonce, a.Decompiled, a.Verified, a.GasUsed, a.TransactionsCount, a.TokenTransfersCount)
	if _, err := db.ExecContext(ctx, sqlstr, a.FetchedCoinBalance, a.FetchedCoinBalanceBlockNumber, a.Hash, a.ContractCode, a.InsertedAt, a.UpdatedAt, a.Nonce, a.Decompiled, a.Verified, a.GasUsed, a.TransactionsCount, a.TokenTransfersCount); err != nil {
		return logerror(err)
	}
	// set exists
	a._exists = true
	return nil
}

// Update updates a Address in the database.
func (a *Address) Update(ctx context.Context, db DB) error {
	switch {
	case !a._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case a._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.addresses SET ` +
		`fetched_coin_balance = $1, fetched_coin_balance_block_number = $2, contract_code = $3, inserted_at = $4, updated_at = $5, nonce = $6, decompiled = $7, verified = $8, gas_used = $9, transactions_count = $10, token_transfers_count = $11 ` +
		`WHERE hash = $12`
	// run
	logf(sqlstr, a.FetchedCoinBalance, a.FetchedCoinBalanceBlockNumber, a.ContractCode, a.InsertedAt, a.UpdatedAt, a.Nonce, a.Decompiled, a.Verified, a.GasUsed, a.TransactionsCount, a.TokenTransfersCount, a.Hash)
	if _, err := db.ExecContext(ctx, sqlstr, a.FetchedCoinBalance, a.FetchedCoinBalanceBlockNumber, a.ContractCode, a.InsertedAt, a.UpdatedAt, a.Nonce, a.Decompiled, a.Verified, a.GasUsed, a.TransactionsCount, a.TokenTransfersCount, a.Hash); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Address to the database.
func (a *Address) Save(ctx context.Context, db DB) error {
	if a.Exists() {
		return a.Update(ctx, db)
	}
	return a.Insert(ctx, db)
}

// Upsert performs an upsert for Address.
func (a *Address) Upsert(ctx context.Context, db DB) error {
	switch {
	case a._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.addresses (` +
		`fetched_coin_balance, fetched_coin_balance_block_number, hash, contract_code, inserted_at, updated_at, nonce, decompiled, verified, gas_used, transactions_count, token_transfers_count` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12` +
		`)` +
		` ON CONFLICT (hash) DO ` +
		`UPDATE SET ` +
		`fetched_coin_balance = EXCLUDED.fetched_coin_balance, fetched_coin_balance_block_number = EXCLUDED.fetched_coin_balance_block_number, contract_code = EXCLUDED.contract_code, inserted_at = EXCLUDED.inserted_at, updated_at = EXCLUDED.updated_at, nonce = EXCLUDED.nonce, decompiled = EXCLUDED.decompiled, verified = EXCLUDED.verified, gas_used = EXCLUDED.gas_used, transactions_count = EXCLUDED.transactions_count, token_transfers_count = EXCLUDED.token_transfers_count `
	// run
	logf(sqlstr, a.FetchedCoinBalance, a.FetchedCoinBalanceBlockNumber, a.Hash, a.ContractCode, a.InsertedAt, a.UpdatedAt, a.Nonce, a.Decompiled, a.Verified, a.GasUsed, a.TransactionsCount, a.TokenTransfersCount)
	if _, err := db.ExecContext(ctx, sqlstr, a.FetchedCoinBalance, a.FetchedCoinBalanceBlockNumber, a.Hash, a.ContractCode, a.InsertedAt, a.UpdatedAt, a.Nonce, a.Decompiled, a.Verified, a.GasUsed, a.TransactionsCount, a.TokenTransfersCount); err != nil {
		return logerror(err)
	}
	// set exists
	a._exists = true
	return nil
}

// Delete deletes the Address from the database.
func (a *Address) Delete(ctx context.Context, db DB) error {
	switch {
	case !a._exists: // doesn't exist
		return nil
	case a._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.addresses ` +
		`WHERE hash = $1`
	// run
	logf(sqlstr, a.Hash)
	if _, err := db.ExecContext(ctx, sqlstr, a.Hash); err != nil {
		return logerror(err)
	}
	// set deleted
	a._deleted = true
	return nil
}

// AddressesByFetchedCoinBalanceHash retrieves a row from 'public.addresses' as a Address.
//
// Generated from index 'addresses_fetched_coin_balance_hash_index'.
func AddressesByFetchedCoinBalanceHash(ctx context.Context, db DB, fetchedCoinBalance sql.NullFloat64, hash []byte) ([]*Address, error) {
	// query
	const sqlstr = `SELECT ` +
		`fetched_coin_balance, fetched_coin_balance_block_number, hash, contract_code, inserted_at, updated_at, nonce, decompiled, verified, gas_used, transactions_count, token_transfers_count ` +
		`FROM public.addresses ` +
		`WHERE fetched_coin_balance = $1 AND hash = $2`
	// run
	logf(sqlstr, fetchedCoinBalance, hash)
	rows, err := db.QueryContext(ctx, sqlstr, fetchedCoinBalance, hash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Address
	for rows.Next() {
		a := Address{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&a.FetchedCoinBalance, &a.FetchedCoinBalanceBlockNumber, &a.Hash, &a.ContractCode, &a.InsertedAt, &a.UpdatedAt, &a.Nonce, &a.Decompiled, &a.Verified, &a.GasUsed, &a.TransactionsCount, &a.TokenTransfersCount); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &a)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// AddressesByFetchedCoinBalance retrieves a row from 'public.addresses' as a Address.
//
// Generated from index 'addresses_fetched_coin_balance_index'.
func AddressesByFetchedCoinBalance(ctx context.Context, db DB, fetchedCoinBalance sql.NullFloat64) ([]*Address, error) {
	// query
	const sqlstr = `SELECT ` +
		`fetched_coin_balance, fetched_coin_balance_block_number, hash, contract_code, inserted_at, updated_at, nonce, decompiled, verified, gas_used, transactions_count, token_transfers_count ` +
		`FROM public.addresses ` +
		`WHERE fetched_coin_balance = $1`
	// run
	logf(sqlstr, fetchedCoinBalance)
	rows, err := db.QueryContext(ctx, sqlstr, fetchedCoinBalance)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Address
	for rows.Next() {
		a := Address{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&a.FetchedCoinBalance, &a.FetchedCoinBalanceBlockNumber, &a.Hash, &a.ContractCode, &a.InsertedAt, &a.UpdatedAt, &a.Nonce, &a.Decompiled, &a.Verified, &a.GasUsed, &a.TransactionsCount, &a.TokenTransfersCount); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &a)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// AddressesByInsertedAt retrieves a row from 'public.addresses' as a Address.
//
// Generated from index 'addresses_inserted_at_index'.
func AddressesByInsertedAt(ctx context.Context, db DB, insertedAt time.Time) ([]*Address, error) {
	// query
	const sqlstr = `SELECT ` +
		`fetched_coin_balance, fetched_coin_balance_block_number, hash, contract_code, inserted_at, updated_at, nonce, decompiled, verified, gas_used, transactions_count, token_transfers_count ` +
		`FROM public.addresses ` +
		`WHERE inserted_at = $1`
	// run
	logf(sqlstr, insertedAt)
	rows, err := db.QueryContext(ctx, sqlstr, insertedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Address
	for rows.Next() {
		a := Address{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&a.FetchedCoinBalance, &a.FetchedCoinBalanceBlockNumber, &a.Hash, &a.ContractCode, &a.InsertedAt, &a.UpdatedAt, &a.Nonce, &a.Decompiled, &a.Verified, &a.GasUsed, &a.TransactionsCount, &a.TokenTransfersCount); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &a)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// AddressByHash retrieves a row from 'public.addresses' as a Address.
//
// Generated from index 'addresses_pkey'.
func AddressByHash(ctx context.Context, db DB, hash []byte) (*Address, error) {
	// query
	const sqlstr = `SELECT ` +
		`fetched_coin_balance, fetched_coin_balance_block_number, hash, contract_code, inserted_at, updated_at, nonce, decompiled, verified, gas_used, transactions_count, token_transfers_count ` +
		`FROM public.addresses ` +
		`WHERE hash = $1`
	// run
	logf(sqlstr, hash)
	a := Address{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, hash).Scan(&a.FetchedCoinBalance, &a.FetchedCoinBalanceBlockNumber, &a.Hash, &a.ContractCode, &a.InsertedAt, &a.UpdatedAt, &a.Nonce, &a.Decompiled, &a.Verified, &a.GasUsed, &a.TransactionsCount, &a.TokenTransfersCount); err != nil {
		return nil, logerror(err)
	}
	return &a, nil
}
