package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// AddressCoinBalance represents a row from 'public.address_coin_balances'.
type AddressCoinBalance struct {
	AddressHash    []byte          `json:"address_hash"`     // address_hash
	BlockNumber    int64           `json:"block_number"`     // block_number
	Value          sql.NullFloat64 `json:"value"`            // value
	ValueFetchedAt sql.NullTime    `json:"value_fetched_at"` // value_fetched_at
	InsertedAt     time.Time       `json:"inserted_at"`      // inserted_at
	UpdatedAt      time.Time       `json:"updated_at"`       // updated_at
}

// AddressCoinBalanceByAddressHashBlockNumber retrieves a row from 'public.address_coin_balances' as a AddressCoinBalance.
//
// Generated from index 'address_coin_balances_address_hash_block_number_index'.
func AddressCoinBalanceByAddressHashBlockNumber(ctx context.Context, db DB, addressHash []byte, blockNumber int64) (*AddressCoinBalance, error) {
	// query
	const sqlstr = `SELECT ` +
		`address_hash, block_number, value, value_fetched_at, inserted_at, updated_at ` +
		`FROM public.address_coin_balances ` +
		`WHERE address_hash = $1 AND block_number = $2`
	// run
	logf(sqlstr, addressHash, blockNumber)
	acb := AddressCoinBalance{}
	if err := db.QueryRowContext(ctx, sqlstr, addressHash, blockNumber).Scan(&acb.AddressHash, &acb.BlockNumber, &acb.Value, &acb.ValueFetchedAt, &acb.InsertedAt, &acb.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &acb, nil
}

// AddressCoinBalancesByValueFetchedAt retrieves a row from 'public.address_coin_balances' as a AddressCoinBalance.
//
// Generated from index 'address_coin_balances_value_fetched_at_index'.
func AddressCoinBalancesByValueFetchedAt(ctx context.Context, db DB, valueFetchedAt sql.NullTime) ([]*AddressCoinBalance, error) {
	// query
	const sqlstr = `SELECT ` +
		`address_hash, block_number, value, value_fetched_at, inserted_at, updated_at ` +
		`FROM public.address_coin_balances ` +
		`WHERE value_fetched_at = $1`
	// run
	logf(sqlstr, valueFetchedAt)
	rows, err := db.QueryContext(ctx, sqlstr, valueFetchedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*AddressCoinBalance
	for rows.Next() {
		acb := AddressCoinBalance{}
		// scan
		if err := rows.Scan(&acb.AddressHash, &acb.BlockNumber, &acb.Value, &acb.ValueFetchedAt, &acb.InsertedAt, &acb.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &acb)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// Address returns the Address associated with the AddressCoinBalance's (AddressHash).
//
// Generated from foreign key 'address_coin_balances_address_hash_fkey'.
func (acb *AddressCoinBalance) Address(ctx context.Context, db DB) (*Address, error) {
	return AddressByHash(ctx, db, acb.AddressHash)
}
