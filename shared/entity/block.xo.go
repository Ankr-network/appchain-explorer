package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// Block represents a row from 'public.blocks'.
type Block struct {
	Consensus       bool            `json:"consensus"`        // consensus
	Difficulty      sql.NullFloat64 `json:"difficulty"`       // difficulty
	GasLimit        float64         `json:"gas_limit"`        // gas_limit
	GasUsed         float64         `json:"gas_used"`         // gas_used
	Hash            []byte          `json:"hash"`             // hash
	MinerHash       []byte          `json:"miner_hash"`       // miner_hash
	Nonce           []byte          `json:"nonce"`            // nonce
	Number          int64           `json:"number"`           // number
	ParentHash      []byte          `json:"parent_hash"`      // parent_hash
	Size            sql.NullInt64   `json:"size"`             // size
	Timestamp       time.Time       `json:"timestamp"`        // timestamp
	TotalDifficulty sql.NullFloat64 `json:"total_difficulty"` // total_difficulty
	InsertedAt      time.Time       `json:"inserted_at"`      // inserted_at
	UpdatedAt       time.Time       `json:"updated_at"`       // updated_at
	RefetchNeeded   sql.NullBool    `json:"refetch_needed"`   // refetch_needed
	BaseFeePerGas   sql.NullFloat64 `json:"base_fee_per_gas"` // base_fee_per_gas
	IsEmpty         sql.NullBool    `json:"is_empty"`         // is_empty
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Block exists in the database.
func (b *Block) Exists() bool {
	return b._exists
}

// Deleted returns true when the Block has been marked for deletion from
// the database.
func (b *Block) Deleted() bool {
	return b._deleted
}

// Insert inserts the Block to the database.
func (b *Block) Insert(ctx context.Context, db DB) error {
	switch {
	case b._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case b._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.blocks (` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17` +
		`)`
	// run
	logf(sqlstr, b.Consensus, b.Difficulty, b.GasLimit, b.GasUsed, b.Hash, b.MinerHash, b.Nonce, b.Number, b.ParentHash, b.Size, b.Timestamp, b.TotalDifficulty, b.InsertedAt, b.UpdatedAt, b.RefetchNeeded, b.BaseFeePerGas, b.IsEmpty)
	if _, err := db.ExecContext(ctx, sqlstr, b.Consensus, b.Difficulty, b.GasLimit, b.GasUsed, b.Hash, b.MinerHash, b.Nonce, b.Number, b.ParentHash, b.Size, b.Timestamp, b.TotalDifficulty, b.InsertedAt, b.UpdatedAt, b.RefetchNeeded, b.BaseFeePerGas, b.IsEmpty); err != nil {
		return logerror(err)
	}
	// set exists
	b._exists = true
	return nil
}

// Update updates a Block in the database.
func (b *Block) Update(ctx context.Context, db DB) error {
	switch {
	case !b._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case b._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.blocks SET ` +
		`consensus = $1, difficulty = $2, gas_limit = $3, gas_used = $4, miner_hash = $5, nonce = $6, number = $7, parent_hash = $8, size = $9, timestamp = $10, total_difficulty = $11, inserted_at = $12, updated_at = $13, refetch_needed = $14, base_fee_per_gas = $15, is_empty = $16 ` +
		`WHERE hash = $17`
	// run
	logf(sqlstr, b.Consensus, b.Difficulty, b.GasLimit, b.GasUsed, b.MinerHash, b.Nonce, b.Number, b.ParentHash, b.Size, b.Timestamp, b.TotalDifficulty, b.InsertedAt, b.UpdatedAt, b.RefetchNeeded, b.BaseFeePerGas, b.IsEmpty, b.Hash)
	if _, err := db.ExecContext(ctx, sqlstr, b.Consensus, b.Difficulty, b.GasLimit, b.GasUsed, b.MinerHash, b.Nonce, b.Number, b.ParentHash, b.Size, b.Timestamp, b.TotalDifficulty, b.InsertedAt, b.UpdatedAt, b.RefetchNeeded, b.BaseFeePerGas, b.IsEmpty, b.Hash); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Block to the database.
func (b *Block) Save(ctx context.Context, db DB) error {
	if b.Exists() {
		return b.Update(ctx, db)
	}
	return b.Insert(ctx, db)
}

// Upsert performs an upsert for Block.
func (b *Block) Upsert(ctx context.Context, db DB) error {
	switch {
	case b._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.blocks (` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17` +
		`)` +
		` ON CONFLICT (hash) DO ` +
		`UPDATE SET ` +
		`consensus = EXCLUDED.consensus, difficulty = EXCLUDED.difficulty, gas_limit = EXCLUDED.gas_limit, gas_used = EXCLUDED.gas_used, miner_hash = EXCLUDED.miner_hash, nonce = EXCLUDED.nonce, number = EXCLUDED.number, parent_hash = EXCLUDED.parent_hash, size = EXCLUDED.size, timestamp = EXCLUDED.timestamp, total_difficulty = EXCLUDED.total_difficulty, inserted_at = EXCLUDED.inserted_at, updated_at = EXCLUDED.updated_at, refetch_needed = EXCLUDED.refetch_needed, base_fee_per_gas = EXCLUDED.base_fee_per_gas, is_empty = EXCLUDED.is_empty `
	// run
	logf(sqlstr, b.Consensus, b.Difficulty, b.GasLimit, b.GasUsed, b.Hash, b.MinerHash, b.Nonce, b.Number, b.ParentHash, b.Size, b.Timestamp, b.TotalDifficulty, b.InsertedAt, b.UpdatedAt, b.RefetchNeeded, b.BaseFeePerGas, b.IsEmpty)
	if _, err := db.ExecContext(ctx, sqlstr, b.Consensus, b.Difficulty, b.GasLimit, b.GasUsed, b.Hash, b.MinerHash, b.Nonce, b.Number, b.ParentHash, b.Size, b.Timestamp, b.TotalDifficulty, b.InsertedAt, b.UpdatedAt, b.RefetchNeeded, b.BaseFeePerGas, b.IsEmpty); err != nil {
		return logerror(err)
	}
	// set exists
	b._exists = true
	return nil
}

// Delete deletes the Block from the database.
func (b *Block) Delete(ctx context.Context, db DB) error {
	switch {
	case !b._exists: // doesn't exist
		return nil
	case b._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.blocks ` +
		`WHERE hash = $1`
	// run
	logf(sqlstr, b.Hash)
	if _, err := db.ExecContext(ctx, sqlstr, b.Hash); err != nil {
		return logerror(err)
	}
	// set deleted
	b._deleted = true
	return nil
}

// BlocksByConsensus retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'blocks_consensus_index'.
func BlocksByConsensus(ctx context.Context, db DB, consensus bool) ([]*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE consensus = $1`
	// run
	logf(sqlstr, consensus)
	rows, err := db.QueryContext(ctx, sqlstr, consensus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Block
	for rows.Next() {
		b := Block{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlocksByInsertedAt retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'blocks_inserted_at_index'.
func BlocksByInsertedAt(ctx context.Context, db DB, insertedAt time.Time) ([]*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE inserted_at = $1`
	// run
	logf(sqlstr, insertedAt)
	rows, err := db.QueryContext(ctx, sqlstr, insertedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Block
	for rows.Next() {
		b := Block{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlocksByIsEmpty retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'blocks_is_empty_index'.
func BlocksByIsEmpty(ctx context.Context, db DB, isEmpty sql.NullBool) ([]*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE is_empty = $1`
	// run
	logf(sqlstr, isEmpty)
	rows, err := db.QueryContext(ctx, sqlstr, isEmpty)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Block
	for rows.Next() {
		b := Block{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlocksByMinerHash retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'blocks_miner_hash_index'.
func BlocksByMinerHash(ctx context.Context, db DB, minerHash []byte) ([]*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE miner_hash = $1`
	// run
	logf(sqlstr, minerHash)
	rows, err := db.QueryContext(ctx, sqlstr, minerHash)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Block
	for rows.Next() {
		b := Block{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlocksByMinerHashNumber retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'blocks_miner_hash_number_index'.
func BlocksByMinerHashNumber(ctx context.Context, db DB, minerHash []byte, number int64) ([]*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE miner_hash = $1 AND number = $2`
	// run
	logf(sqlstr, minerHash, number)
	rows, err := db.QueryContext(ctx, sqlstr, minerHash, number)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Block
	for rows.Next() {
		b := Block{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlocksByNumber retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'blocks_number_index'.
func BlocksByNumber(ctx context.Context, db DB, number int64) ([]*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE number = $1`
	// run
	logf(sqlstr, number)
	rows, err := db.QueryContext(ctx, sqlstr, number)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Block
	for rows.Next() {
		b := Block{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlockByHash retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'blocks_pkey'.
func BlockByHash(ctx context.Context, db DB, hash []byte) (*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE hash = $1`
	// run
	logf(sqlstr, hash)
	b := Block{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, hash).Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
		return nil, logerror(err)
	}
	return &b, nil
}

// BlocksByTimestamp retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'blocks_timestamp_index'.
func BlocksByTimestamp(ctx context.Context, db DB, timestamp time.Time) ([]*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE timestamp = $1`
	// run
	logf(sqlstr, timestamp)
	rows, err := db.QueryContext(ctx, sqlstr, timestamp)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Block
	for rows.Next() {
		b := Block{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlockByNumber retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'one_consensus_block_at_height'.
func BlockByNumber(ctx context.Context, db DB, number int64) (*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE number = $1`
	// run
	logf(sqlstr, number)
	b := Block{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, number).Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
		return nil, logerror(err)
	}
	return &b, nil
}

// BlockByParentHash retrieves a row from 'public.blocks' as a Block.
//
// Generated from index 'one_consensus_child_per_parent'.
func BlockByParentHash(ctx context.Context, db DB, parentHash []byte) (*Block, error) {
	// query
	const sqlstr = `SELECT ` +
		`consensus, difficulty, gas_limit, gas_used, hash, miner_hash, nonce, number, parent_hash, size, timestamp, total_difficulty, inserted_at, updated_at, refetch_needed, base_fee_per_gas, is_empty ` +
		`FROM public.blocks ` +
		`WHERE parent_hash = $1`
	// run
	logf(sqlstr, parentHash)
	b := Block{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, parentHash).Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
		return nil, logerror(err)
	}
	return &b, nil
}

// Address returns the Address associated with the Block's (MinerHash).
//
// Generated from foreign key 'blocks_miner_hash_fkey'.
func (b *Block) Address(ctx context.Context, db DB) (*Address, error) {
	return AddressByHash(ctx, db, b.MinerHash)
}

// BlocksByNumberLimit runs a custom query, returning results as Block.
func BlocksByNumberLimit(ctx context.Context, db DB, number, limit uint64) ([]*Block, error) {
	// query
	const sqlstr = `SELECT * FROM "blocks" ` +
		`WHERE $1 >= number ` +
		`ORDER BY "timestamp" DESC ` +
		`LIMIT $2`
	// run
	logf(sqlstr, number, limit)
	rows, err := db.QueryContext(ctx, sqlstr, number, limit)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Block
	for rows.Next() {
		var b Block
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlocksByLimit runs a custom query, returning results as Block.
func BlocksByLimit(ctx context.Context, db DB, limit uint64) ([]*Block, error) {
	// query
	const sqlstr = `SELECT * FROM "blocks" ` +
		`ORDER BY "timestamp" DESC ` +
		`LIMIT $1`
	// run
	logf(sqlstr, limit)
	rows, err := db.QueryContext(ctx, sqlstr, limit)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Block
	for rows.Next() {
		var b Block
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
} // BlocksByLimit runs a custom query, returning results as Block.
func BlocksByLimit(ctx context.Context, db DB, limit uint64) ([]*Block, error) {
	// query
	const sqlstr = `SELECT * FROM "blocks" ` +
		`ORDER BY "timestamp" DESC ` +
		`LIMIT $1`
	// run
	logf(sqlstr, limit)
	rows, err := db.QueryContext(ctx, sqlstr, limit)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Block
	for rows.Next() {
		var b Block
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// BlocksByNumberLimit runs a custom query, returning results as Block.
func BlocksByNumberLimit(ctx context.Context, db DB, number, limit uint64) ([]*Block, error) {
	// query
	const sqlstr = `SELECT * FROM "blocks" ` +
		`WHERE $1 >= number ` +
		`ORDER BY "timestamp" DESC ` +
		`LIMIT $2`
	// run
	logf(sqlstr, number, limit)
	rows, err := db.QueryContext(ctx, sqlstr, number, limit)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Block
	for rows.Next() {
		var b Block
		// scan
		if err := rows.Scan(&b.Consensus, &b.Difficulty, &b.GasLimit, &b.GasUsed, &b.Hash, &b.MinerHash, &b.Nonce, &b.Number, &b.ParentHash, &b.Size, &b.Timestamp, &b.TotalDifficulty, &b.InsertedAt, &b.UpdatedAt, &b.RefetchNeeded, &b.BaseFeePerGas, &b.IsEmpty); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &b)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
