package entity

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"time"
)

// AddressName represents a row from 'public.address_names'.
type AddressName struct {
	AddressHash []byte    `json:"address_hash"` // address_hash
	Name        string    `json:"name"`         // name
	Primary     bool      `json:"primary"`      // primary
	InsertedAt  time.Time `json:"inserted_at"`  // inserted_at
	UpdatedAt   time.Time `json:"updated_at"`   // updated_at
	Metadata    []byte    `json:"metadata"`     // metadata
}

// AddressNameByAddressHash retrieves a row from 'public.address_names' as a AddressName.
//
// Generated from index 'address_names_address_hash_index'.
func AddressNameByAddressHash(ctx context.Context, db DB, addressHash []byte) (*AddressName, error) {
	// query
	const sqlstr = `SELECT ` +
		`address_hash, name, primary, inserted_at, updated_at, metadata ` +
		`FROM public.address_names ` +
		`WHERE address_hash = $1`
	// run
	logf(sqlstr, addressHash)
	an := AddressName{}
	if err := db.QueryRowContext(ctx, sqlstr, addressHash).Scan(&an.AddressHash, &an.Name, &an.Primary, &an.InsertedAt, &an.UpdatedAt, &an.Metadata); err != nil {
		return nil, logerror(err)
	}
	return &an, nil
}

// AddressNameByAddressHashName retrieves a row from 'public.address_names' as a AddressName.
//
// Generated from index 'unique_address_names'.
func AddressNameByAddressHashName(ctx context.Context, db DB, addressHash []byte, name string) (*AddressName, error) {
	// query
	const sqlstr = `SELECT ` +
		`address_hash, name, primary, inserted_at, updated_at, metadata ` +
		`FROM public.address_names ` +
		`WHERE address_hash = $1 AND name = $2`
	// run
	logf(sqlstr, addressHash, name)
	an := AddressName{}
	if err := db.QueryRowContext(ctx, sqlstr, addressHash, name).Scan(&an.AddressHash, &an.Name, &an.Primary, &an.InsertedAt, &an.UpdatedAt, &an.Metadata); err != nil {
		return nil, logerror(err)
	}
	return &an, nil
}
